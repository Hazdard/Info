Le model OSI (Open Systems Interconnections) est un model standard pour la théorie des connections réseau. En réalité on utilise le model plus compact TCP/IP. Le model OSI est constitué de 7 couches :

Couche 7 : Applications 
Fournie principalement des options réseau aux programmes tournant sur notre machine. Cette couche travaille quasiment exclusivement avec les applications, leur fournissant une interface pour transmettre des données. Quand des données sont envoyées à la couche 'applications', elles sont transmises à la couche 'présentation'.

Couche 6 : Présentation 
La couche 'présentation' recçoit les informations de la couche applicative, mais ces données peuvent être dans un format non reconnu par la machine receptrice. La couche de présentation traduit donc ces données dans un format standard, et s'occupe du cryptage et de la compression, et autres transformations des données. Elles sont ensuite transmises à la couche 'session'.

Couche 5 : Session
Une fois les données dans le bon format, la couche 'session' cherche à créer une connection avec l'autre ordinateur via le réseau. Si il n'y arrive pas, il renvoie une erreur et l'opération se termine ici. Si la session peut être établie, les couches 'session' des deux machines cherchent à la maintenir et synchroniser les communications.
Cette couche est importante car la session qu'elle crée est unique à la communication en question. Cela permet de faire des requêtes à plusieurs serveurs sans que les données soient mélangées. Une fois la transmission établie, les données sont passées à la couche de 'transport'

Couche 4 : Transport
Le premier rôle de cette couche est de choisir le protocole avec lequel les données seront transmises. Les deux protocoles les plus communs de la couche 4 sont: TCP (Transmission Control Procotol) et UDP (User Datagrams Protocol).
Avec TCP, la transmission repose sur la connection entre les machines, càd qu'une connection entre les machines est établie et maintenue pour la durée de la requête. Cela permet une communication sure, car cette connection peut être utilisée pour assurer que tous les packets vont au bon endroit, que les données circulent à une vitesse correcte, et que les données perdues sont réenvoyées.
Avec UDP, c'est l'opposé : les packets sont "jetés" à la machine receptrice, et si elle ne peut pas les accepter, c'est son problème (Ex: Skype). 
TCP est donc plutôt utilisé dans des situations où la précision est plus importante que la vitesse (web, file transfer, ...) et UDP dans des situations où la vitesse est plus importante (streaming).
Une fois le protocole choisis, la couche de transport divise la transmission en 'bite-sized pieces' (PDU = Protocol Data Unit), qui sont appelés des segments pour TCP, des datagrams pour UDP; rendant le message ainsi plus facilement transportable.

Couche 3 : Réseau (Network)
La couche réseau est responsable de localiser la destination de notre requête, elle trouve le chemin de parcours des données à partir de l'IP de notre récepteur. Elle relaye donc des 'paquets' (PDU) pour les rapprocher de leur destination finale. Le chemin choisi est optimal grace à des protocoles comme OSPF (Open Shortest Path First), et RIP (Routing Information Protocol). Le chemin pris est choisis en fonction de : rapidité, fiabilité, connection physique la plus rapide (ADSL ou fibre ?).

Couche 2 : Liaison (Data Link)
Elle est dédiée à l'aspect physique de la transmission. Cette couche reçoit un packet provenant de la couche 'réseau' contenant entre autres l'IP receptrice, et ajoute alors l'adresse physique (MAC) du récepteur, qui permet d'assurer l'identification d'un ordinateur au sein d'un réseau (PDU: Frames).
Les adresses MAC sont gravées à l'usine, donc inchageables, mais peuvent être usurpées. L'adresse MAC permet d'identifier exactement où envoyer l'information.
De plus la couche de liaison doit aussi mettre les données dans un format approprié à la transmission.
Quand la couche lisaion reçoit des données, elle vérifie aussi qu'elles n'ont pas étés corompues lors de la transmission, ce qui peut arriver lors du transfert à la couche 1.

Couche 1 : Physique
La couche physique correspond à la partie hardware de l'ordinateur. Des signaux électriques sont alors envoyées pour transmettre les données. La couche physique doit donc convertir les données binaires en signaux et les transmettre dans le réseau, mais aussi récupérer des signaux provenant du réseau et les convertir en données binaires.

Les 3 premières couches sont appelées couches matérielles, tandis que les suivantes sont les couches hautes.

Quelques protocoles associés à chaque couche :
7 : BitTorrent, HTTP, HTTPS, IMAP, SSH, Telnet, FTP, DNS
6 : HTML, ASCII, Unicode, XML, JSON
5 : RPC, NetBios, AppleTalk
4 : TCP, UDP
3 : DHCP, IP, Ipv4, Ipv6, ICMP
2 : Ethernet (il y en a d'autres mais osef)
1 : ADSL, VDSL, Bluetooth, Thunderbolt, Wi-Fi


Au fur et à mesure du passage des données dans les différentes couches, des informations leurs sont rajoutées, Ex : le passage dans la couche 'réseau' se traduit par l'ajout de l'IP de la source et du destinataire ; la couche 'transport' rajoute l'information concernant le protocle choisis, la couche 'liaison' rajoute une donnée à la fin de la transmission, assurant que les données ne sont pas corrompues, ce qui renforce la sécurité car il n'est plus possible d'intercepter les données et les modifier sans changer cette donnée de fin.
Ce processus globale s'appelle l'encapsulation : c'est le processus par lequel des données sont envoyées d'un ordinateur vers un autre.
Les données encapsulées ont un nom différent à chaque étape : 7 = 6 = 5 = 'Data' ; 4 = 'Segments/Datagrams' ; 3 = 'Packets' ; 2 = 'Frames' ; 1 = 'Bits' .

Une fois le message reçu, le processus est fait en sens inverse, on parle de dé-encapsulation. Les données remontent de la couche physique vers la couche applicative.

Ces processus sont essentiels car donnent une manière standard de transmettre des informations, impliquant donc que toutes les communications vont suivre la même méthode, permettant à n'importe quel appareil d'envoyer un message en étant sur d'être compris.


LE MODEL TCP/IP

C'est un model très similaire au model OSI, mais plus vieux. Il regroupe les couches application, presentaion et session dans une unique couche application, renomme 'reseau' en 'internet', et regroupe les couches liaison et physique en une unique couche 'Interface réseau' (Network Interface).

Cependant les processus d'encapsulation/dé-encapsulation restent exactement identiques entre OSI et TCP/IP.
D'un point de vue pratique, il faut plus visualiser le modèle TCP/IP comme un enchainement de protocoles, plutôt que comme un tableau à 4 lignes. Le nom TCP/IP vient donc des deux protocoles les plus importants : Transmission Control Protocol, qui contrôle le flux de données entre deux points ; et Internet Protocol, qui contrôle comment les packets sont adressés et envoyés. D'autres protocoles composent TCP/IP, mais on ne les verra pas pour le moment.

La manière d'établir la connection stable entre deux machines via TCP s'appelle 'three-way-handshake' :
Quand notre machine tente de se connecter, elle envoie une requête contenant un bit SYN (synchronise), qui fait le premier pas pour lancer la connection. Le serveur a répondre avec un paquet contenant le bit SYN et un bit ACK (acknowledgment) ; et finalement notre ordinateur répond avec un packet contenant le bit ACK, confirmant que la connection est établie. Une fois le 'three-way-handshake' fait, les données peuvent être transmises entre les deux machines. Toute donnée perdue ou corrompue durant la transmission est réenvoyée, la transmission étant ainsi sans pertes.


PING

La commande ping est utilisée pour savoir si la connection à une source distante est possible. ping utilise le protocole ICMP, qui fait partie des autres protocoles du modèle TCP/IP. Le protocole ICMP travaille sur la couche 'réseau' du modèle OSI, et donc la couche Internet du modèle TCP/IP.
La syntaxe basique est : `ping <target>` ; Elle peut aussi être utilisée pour déterminer l'IP de la cible. ping est présent sur quasiment tout ce qui existe et qui est connecté au réseau. 
Voir le man pour plus de détails.


TRACEROUTE 

Internet est composé d'un grand nombre de noeuds et de serveurs, tous connectés. Cela signifie que pour accéder au contenu que l'on veut, il faut passer par plusieurs serveurs afin d'arriver à la destination finale. Pour voir toutes les destinations intermédiares, on utilise la commande : `traceroute <target>`.
Par défaut, traceroute utilise le protocole ICMP, et son équivalent Unix utilise UDP. On peut le changer avec des paramètres lors de l'appel de la commande.


WHOIS

Les noms de domaine permettent de ne pas avoir à se souvenir de l'adresse IP d'un site pour s'y connecter (vive la vie !). Les noms de domaines sont loués par des 'Domains Registrars'.
whois permet de savoir à qui un nom de domaine est lié. `whois <domain>` pour avoir la liste des informations accessibles (pas mal de trucs qui peuvent être interessants). Marche aussi avec l'adresse IP.


DIG

Un URL est converti en adresse IP via le protocole DNS du modèle TCP/IP (Domain Name System). A un niveau basique, DNS nous permet de demander à un serveur spécial quelle est l'IP du site que l'on veut consulter. 
Détails :
Quand on fait une requête à un site, notre ordinateur cherche d'abord si il a l'IP du site stockée en cache local. Si oui, c'est bon, sinon, étape suivante. 
Notre ordinateur envoie alors une requête à un serveur DNS récursif pour savoir si l'adresse est connue. Beaucoup d'ISP (Internet Service Provider) ont leurs propres serveurs DNS récursifs, mais Google et OpenDNS en controlent aussi. Savoir comment se connecter à un serveur récursif est donc dans notre routeur. De plus ce serveur maintien un cache des domaines populaires pour les rendre accessibles rapidement. Si le site n'est pas dans le cache, le serveur récursif transmet la requête à un 'root name server'.
Avant 2004, il y avait précisement 13 `root name DNS`, mais maintenant il y en a beaucoup plus (même si ces 13 serveurs sont toujours accessibles). Les 'root name server' gardent principalement une liste des serveurs DNS du niveau en dessous, choisissant le plus approprié pour rediriger notre requête. ces sous-servers sont appelés 'Top-Level Domain servers'. 
Les serveurs TLD sont séparés en extensions (.com ; .fr ; .gouv ; .co.uk ; etc ...) Si on cherche un serveur en .truc , notre requête sera redirigé vers le TLD .truc . De plus les serveurs TLD ont une liste des serveurs du niveau inférieur : 'Authoritative name servers'. 
Notre requête est donc redirigée vers l'ANS le plus approprié. Les ANS sont utilisés pour stocker les DNS directement, chaque site a donc ses DNS stockées dans un ANS quelquepart. Lorsque notre requête atteint l'ANS approprié, il renvoie l'information utile, permettant de nous connecter à l'adresse IP correspondant au site visité.

Quand on visite un site, tout cela se fait automatiquement, mais on peut le faire manuellement avec dig (Domain Information Groper). dig permet de chercher manuellement et récursivement des IP dans des serveurs DNS de notre choix pour certains domaines.
`dig @<dns-server-ip> <domain> <type>`. C'est un outil de dépannage réseau très efficace.
La commande renvoie entre autres, dans la section ANSWER, les ip trouvées via le DNS donné, correspondant au nom de domaine cherché. Il y a aussi le TTL (Time To Live), qui est donné en secondes dans la deuxième colonne de la section ANSWER.
Seule la section <domain> est obligatoire. On peut préciser le DNS choisi, et aussi les types d'enregistrement (par défaut c'est A, càd 'Host address', donc l'adresse IP).
Liste de quelques types d'enregistrement classiques :
A (Host address); AAAA (IPv6 host address); CNAME (Canonical name for an alias, ne fournit pas d'adresse IP); MX (Mail eXchange, dirige le courrier vers un serveur de messagerie); NS (Name Server, stocke les DNS pour un nom de domaine); PTR (Pointer, fourni un nom de domaine dans les recherches inversées); SOA (Start Of Authority, stocke les informations administratives d'un domaine); SRV (location of service, spécifie un port pour des services spécifiques); TXT (Descriptive text).
On peut tracer la recherche de DNS avec +trace :
`dig <domain> +trace`
On peut aussi faire une recherche inversée, càd donner les DNS associés à une adresse IP :
`dig -x <IP>` ; et il préférable de rajouter +answer pour avoir un affichage détaillé. Attention : si un enregistrement PTR n'est pas défini pour l'adresse, la recherche inversée n'aboutira pas.
Si on ne fournis pas l’argument serveur, alors dig utilise le serveur de nom figurant dans le fichier /etc/resolv.conf   .
On peut rajouter +answer à la fin de la requête pour détailler la section des réponses. +trace pour faire la traceroute de dig. +short pour avoir juste les IP.
-f fichier permet de faire la recherche dig pour tous les noms de domaine présents dans le fichier.